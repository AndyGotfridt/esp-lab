let DEVICE = null;let CURRENT_VERSION = null;let FIRMWARE_CHANNEL = null;document.addEventListener('DOMContentLoaded', function () { setTimeout(function() { updateLanguageSelector(); }, 100); if (window.location.hostname !== '' || getTestIP()) { const testIP = getTestIP(); loadVersionInfo(testIP); loadConfig(); updateWifiStatus(); updateLdrValue(); setTimeout(checkForUpdates, 2000); setInterval(updateWifiStatus, 10000); setInterval(updateLdrValue, 2000); setInterval(checkForUpdates, 3600000); } setInterval(updatePreview, 1000); updatePreview(); setInterval(checkNightMode, 60000); checkNightMode();});function changeLanguage(lang) { console.log('[LANG] Cambiando idioma a:', lang); i18n.changeLanguage(lang).then(function(success) { if (success) { console.log('[LANG] Idioma cambiado exitosamente a:', lang); setTimeout(initializeTooltips, 100); } });}function updateLanguageSelector() { var currentLang = i18n.getCurrentLanguage(); var selector = document.getElementById('languageSelector'); if (selector && currentLang) { selector.value = currentLang; }}window.addEventListener('i18nReady', function(e) { console.log('[i18n] Sistema listo con idioma:', e.detail.lang); initializeTooltips();});window.addEventListener('languageChanged', function(e) { console.log('[LANG] Evento languageChanged:', e.detail.lang); updateLanguageSelector();});window.addEventListener('languageChanged', function() { generateThemeButtons();});function initializeTooltips() { var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')); tooltipTriggerList.forEach(function (tooltipTriggerEl) { var tooltip = bootstrap.Tooltip.getInstance(tooltipTriggerEl); if (tooltip) { tooltip.dispose(); } new bootstrap.Tooltip(tooltipTriggerEl); });}function toggleBrightnessControls() { var isAutoEnabled = document.getElementById('autobrightness').checked; var manualControl = document.getElementById('manualBrightnessControl'); var autoControls = document.getElementById('autoBrightnessControls'); if (isAutoEnabled) { manualControl.classList.add('collapsed'); autoControls.classList.remove('collapsed'); setTimeout(function () { manualControl.classList.add('d-none'); }, 300); } else { manualControl.classList.remove('d-none'); manualBrightnessControl.classList.remove('d-none'); setTimeout(function () { manualControl.classList.remove('collapsed'); }, 10); autoControls.classList.add('collapsed'); }}document.addEventListener('DOMContentLoaded', function() { document.getElementById('autobrightness').addEventListener('change', function () { toggleBrightnessControls(); checkNightMode(); updateLdrValue(); autoSave(); }); document.getElementById('brightness').addEventListener('input', function () { document.getElementById('brightnessValue').textContent = this.value; autoSave(); }); document.getElementById('minBrightness').addEventListener('input', function () { document.getElementById('minBrightnessValue').textContent = this.value; autoSave(); }); document.getElementById('maxBrightness').addEventListener('input', function () { document.getElementById('maxBrightnessValue').textContent = this.value; autoSave(); }); document.getElementById('nightBrightness').addEventListener('input', function () { document.getElementById('nightBrightnessValue').textContent = this.value; autoSave(); });});function checkNightMode() { var autobrightness = document.getElementById('autobrightness').checked; var scheduleEnabled = document.getElementById('scheduleEnabled').checked; var manualControl = document.getElementById('manualBrightnessControl'); var warning = document.getElementById('nightModeWarning'); if (manualControl.style.display === 'none' || !scheduleEnabled) { warning.classList.add('d-none'); return; } var timeOff = document.getElementById('timeOff').value.split(':'); var timeOn = document.getElementById('timeOn').value.split(':'); var hourOff = parseInt(timeOff[0]); var minuteOff = parseInt(timeOff[1]); var hourOn = parseInt(timeOn[0]); var minuteOn = parseInt(timeOn[1]); var now = new Date(); var currentMinutes = now.getHours() * 60 + now.getMinutes(); var offMinutes = hourOff * 60 + minuteOff; var onMinutes = hourOn * 60 + minuteOn; var isNightMode = false; if (onMinutes < offMinutes) { isNightMode = (currentMinutes < onMinutes || currentMinutes >= offMinutes); } else { isNightMode = (currentMinutes >= offMinutes && currentMinutes < onMinutes); } if (isNightMode) { warning.classList.remove('d-none'); } else { warning.classList.add('d-none'); }}document.addEventListener('DOMContentLoaded', function() { document.getElementById('scheduleEnabled').addEventListener('change', function () { checkNightMode(); autoSave(); }); document.getElementById('timeOff').addEventListener('change', function () { checkNightMode(); autoSave(); }); document.getElementById('timeOn').addEventListener('change', function () { checkNightMode(); autoSave(); });});function updatePreview() { var now = new Date(); var h = String(now.getHours()).padStart(2, '0'); var m = String(now.getMinutes()).padStart(2, '0'); var hc = document.getElementById('colorHours').value; var mc = document.getElementById('colorMinutes').value; var sc = document.getElementById('colorSeparator').value; document.getElementById('previewHours').textContent = h; document.getElementById('previewHours').style.color = hc; document.getElementById('previewSeparator').textContent = ':'; document.getElementById('previewSeparator').style.color = sc; document.getElementById('previewMinutes').textContent = m; document.getElementById('previewMinutes').style.color = mc;}document.addEventListener('DOMContentLoaded', function() { document.getElementById('colorHours').addEventListener('input', function () { updatePreview(); autoSave(); }); document.getElementById('colorMinutes').addEventListener('input', function () { updatePreview(); autoSave(); }); document.getElementById('colorSeparator').addEventListener('input', function () { updatePreview(); autoSave(); });});const quickThemes = [ { key: 'classic', h: '#FF0000', s: '#FF0000', m: '#FF0000' }, { key: 'neon', h: '#FF00FF', s: '#00FFFF', m: '#FFFF00' }, { key: 'rainbow', h: '#FF0000', s: '#00FF00', m: '#0000FF' }, { key: 'ocean', h: '#0066CC', s: '#00CCFF', m: '#66FFFF' }, { key: 'fire', h: '#FF4500', s: '#FF6347', m: '#FF7F50' }, { key: 'matrix', h: '#00FF00', s: '#00FF00', m: '#00FF00' }, { key: 'purple', h: '#9932CC', s: '#BA55D3', m: '#DA70D6' }, { key: 'sunset', h: '#FFD700', s: '#FFA500', m: '#FF8C00' }, { key: 'white', h: '#FFFFFF', s: '#CCCCCC', m: '#999999', border: true }];function applyTheme(h, m, s) { document.getElementById('colorHours').value = h; document.getElementById('colorMinutes').value = m; document.getElementById('colorSeparator').value = s; updatePreview(); autoSave();}function generateThemeButtons() { const container = document.getElementById('themesContainer'); if (!container) return; container.innerHTML = ''; quickThemes.forEach(theme => { const col = document.createElement('div'); col.className = 'col-4'; const button = document.createElement('button'); button.type = 'button'; button.className = 'btn w-100 theme-btn'; button.onclick = () => applyTheme(theme.h, theme.m, theme.s); const gradient = `linear-gradient(90deg, ${theme.h} 33%, ${theme.s} 66%, ${theme.m})`; button.style.background = gradient; if (theme.border) { button.style.border = '1px solid #ddd'; } const small = document.createElement('small'); small.setAttribute('data-i18n', `themes.${theme.key}`); small.textContent = theme.key.charAt(0).toUpperCase() + theme.key.slice(1); button.appendChild(small); col.appendChild(button); container.appendChild(col); }); if (window.i18n && window.i18n.applyTranslations) { window.i18n.applyTranslations(); } console.log('[THEMES] Botones de temas generados dinámicamente');}if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', generateThemeButtons);} else { generateThemeButtons();}document.addEventListener('DOMContentLoaded', function() { document.getElementById('timezoneSelect').addEventListener('change', function () { document.getElementById('timezoneOffset').value = this.value; }); document.getElementById('timezoneSearch').addEventListener('input', function () { var filter = this.value.toLowerCase(); var opts = document.querySelectorAll('#timezoneSelect option'); var optgroups = document.querySelectorAll('#timezoneSelect optgroup'); for (var i = 0; i < optgroups.length; i++) { optgroups[i].style.display = '' } for (var i = 0; i < opts.length; i++) { var text = opts[i].textContent.toLowerCase(); if (text.indexOf(filter) > -1 || filter === '') { opts[i].style.display = '' } else { opts[i].style.display = 'none' } } });});var autoSaveTimer;function autoSave() { clearTimeout(autoSaveTimer); autoSaveTimer = setTimeout(function () { saveConfig(true); }, 500);}function saveConfig(silent) { var timeOn = document.getElementById('timeOn').value.split(':'); var timeOff = document.getElementById('timeOff').value.split(':'); var config = { colorHours: parseInt(document.getElementById('colorHours').value.replace('#', ''), 16), colorMinutes: parseInt(document.getElementById('colorMinutes').value.replace('#', ''), 16), colorSeparator: parseInt(document.getElementById('colorSeparator').value.replace('#', ''), 16), brightness: parseInt(document.getElementById('brightness').value), autobrightness: document.getElementById('autobrightness').checked, minBrightness: parseInt(document.getElementById('minBrightness').value), maxBrightness: parseInt(document.getElementById('maxBrightness').value), scheduleEnabled: document.getElementById('scheduleEnabled').checked, hourOn: parseInt(timeOn[0]), minuteOn: parseInt(timeOn[1]), hourOff: parseInt(timeOff[0]), minuteOff: parseInt(timeOff[1]), nightBrightness: parseInt(document.getElementById('nightBrightness').value), timezoneOffset: parseFloat(document.getElementById('timezoneOffset').value), ntpServer: document.getElementById('ntpServer').value }; fetch('/saveConfig', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(config) }) .then(response => response.text()) .then(data => { showToast('success', i18n.t('toasts.changes_saved'), silent ? 1500 : 3500); }) .catch(err => { console.error('[SAVE-CONFIG] ERROR:', err); showToast('danger', i18n.t('toasts.save_error'), 3500); });}function saveAdvancedConfig() { var timeOn = document.getElementById('timeOn').value.split(':'); var timeOff = document.getElementById('timeOff').value.split(':'); var fullConfig = { colorHours: parseInt(document.getElementById('colorHours').value.replace('#', ''), 16), colorMinutes: parseInt(document.getElementById('colorMinutes').value.replace('#', ''), 16), colorSeparator: parseInt(document.getElementById('colorSeparator').value.replace('#', ''), 16), brightness: parseInt(document.getElementById('brightness').value), autobrightness: document.getElementById('autobrightness').checked, minBrightness: parseInt(document.getElementById('minBrightness').value), maxBrightness: parseInt(document.getElementById('maxBrightness').value), scheduleEnabled: document.getElementById('scheduleEnabled').checked, hourOn: parseInt(timeOn[0]), minuteOn: parseInt(timeOn[1]), hourOff: parseInt(timeOff[0]), minuteOff: parseInt(timeOff[1]), nightBrightness: parseInt(document.getElementById('nightBrightness').value), timezoneOffset: parseFloat(document.getElementById('timezoneOffset').value), ntpServer: document.getElementById('ntpServer').value, ledPin: parseInt(document.getElementById('ledPin').value), ldrPin: parseInt(document.getElementById('ldrPin').value), numLeds: parseInt(document.getElementById('numLeds').value), updateServerUrl: document.getElementById('updateServerUrl').value, updateChannel: document.getElementById('updateChannel').value }; fetch('/saveConfig', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(fullConfig) }) .then(response => response.text()) .then(data => { if (data === 'OK_RESTART') { showToast('warning', i18n.t('toasts.restart_warning'), 5000); } else { showToast('success', i18n.t('toasts.config_saved'), 3500); } }) .catch(err => { console.error('[SAVE-MODAL] ERROR: ', err); showToast('danger', i18n.t('toasts.save_error'), 3500); });}function showToast(type, message, delay) { var toastEl = document.getElementById('successToast'); var toastBody = toastEl.querySelector('.toast-body'); var icon = type === 'success' ? 'circle-check' : type === 'danger' ? 'circle-xmark' : type === 'warning' ? 'rotate' : 'info-circle'; toastBody.innerHTML = `<i class="fa-solid fa-${icon} me-2"></i>${message}`; toastEl.className = `toast align-items-center text-white bg-${type} border-0`; var toast = new bootstrap.Toast(toastEl, {autohide: true, delay: delay}); toast.show(); if (type !== 'success') { setTimeout(function () { toastEl.className = 'toast align-items-center text-white bg-success border-0'; }, delay); }}function loadConfig() { fetch('/getConfig') .then(r => r.json()) .then(config => { document.getElementById('colorHours').value = '#' + config.colorHours.toString(16).padStart(6, '0'); document.getElementById('colorMinutes').value = '#' + config.colorMinutes.toString(16).padStart(6, '0'); document.getElementById('colorSeparator').value = '#' + config.colorSeparator.toString(16).padStart(6, '0'); document.getElementById('brightness').value = config.brightness; document.getElementById('brightnessValue').textContent = config.brightness; document.getElementById('autobrightness').checked = config.autobrightness; document.getElementById('minBrightness').value = config.minBrightness; document.getElementById('minBrightnessValue').textContent = config.minBrightness; document.getElementById('maxBrightness').value = config.maxBrightness; document.getElementById('maxBrightnessValue').textContent = config.maxBrightness; document.getElementById('scheduleEnabled').checked = config.scheduleEnabled; document.getElementById('timeOn').value = String(config.hourOn).padStart(2, '0') + ':' + String(config.minuteOn).padStart(2, '0'); document.getElementById('timeOff').value = String(config.hourOff).padStart(2, '0') + ':' + String(config.minuteOff).padStart(2, '0'); document.getElementById('nightBrightness').value = config.nightBrightness; document.getElementById('nightBrightnessValue').textContent = config.nightBrightness; document.getElementById('timezoneOffset').value = config.timezoneOffset; document.getElementById('timezoneSelect').value = config.timezoneOffset; if (config.ntpServer) { document.getElementById('ntpServer').value = config.ntpServer; } if (config.ledPin !== undefined) { document.getElementById('ledPin').value = config.ledPin; } if (config.ldrPin !== undefined) { document.getElementById('ldrPin').value = config.ldrPin; } if (config.numLeds !== undefined) { document.getElementById('numLeds').value = config.numLeds; } if (config.updateServerUrl) { document.getElementById('updateServerUrl').value = config.updateServerUrl; } if (config.updateChannel) { document.getElementById('updateChannel').value = config.updateChannel; } setTimeout(function () { updatePreview(); toggleBrightnessControls(); checkNightMode(); }, 50); }) .catch(err => console.error('[CONFIG] ERROR:', err));}function resetWifi() { if (confirm(i18n.t('dialogs.wifi_reset_confirm'))) { alert(i18n.t('dialogs.wifi_reset_alert')); }}function testLeds() { if (confirm(i18n.t('dialogs.led_test_confirm'))) { showToast('success', i18n.t('toasts.test_running'), 2000); fetch('/testLeds') .then(response => response.text()) .then(data => { setTimeout(function () { showToast('success', i18n.t('toasts.test_completed'), 3500); }, 8000); }) .catch(err => { console.error('[TEST] ERROR:', err); showToast('danger', i18n.t('toasts.test_error'), 3500); }); }}function autoUpdateFirmware() { var firmwareUrl = window.latestFirmwareUrl; var webAssets = window.latestWebAssets || []; if (!firmwareUrl || firmwareUrl === '#') { alert('No hay URL de descarga disponible. Verifica tu conexión.'); return; } var confirmMsg = 'El ESP32 descargará y actualizará:\n\n'; confirmMsg += '• Firmware (.bin)\n'; if (webAssets.length > 0) { confirmMsg += '• Archivos web (' + webAssets.length + ')\n'; } confirmMsg += '\n⚠️ NO desconectes el ESP32 durante el proceso (~60-90 seg)'; if (!confirm(confirmMsg)) { return; } var progressDiv = document.getElementById('updateProgress'); var progressBar = document.getElementById('updateProgressBar'); var statusText = document.getElementById('updateStatus'); var autoBtn = document.getElementById('updateAutoBtn'); progressDiv.classList.remove('d-none'); autoBtn.disabled = true; autoBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Actualizando...'; progressBar.style.width = '10%'; progressBar.textContent = '10%'; progressBar.classList.add('progress-bar-animated'); if (webAssets.length > 0) { statusText.textContent = 'Actualizando archivos web (' + webAssets.length + ')...'; var filePromises = webAssets.map(function (asset) { var updateUrl = '/updateFile?url=' + encodeURIComponent(asset.url) + '&path=' + encodeURIComponent(asset.path); if (asset.sha256) { updateUrl += '&sha256=' + encodeURIComponent(asset.sha256); console.log('[UPDATE] Verificación SHA256 habilitada para:', asset.name); } return fetch(updateUrl) .then(response => response.text()) .then(data => { if (data.includes('failed') || data.includes('error')) { throw new Error(data); } console.log('[UPDATE] ✓ Archivo actualizado:', asset.path); }); }); Promise.all(filePromises) .then(function () { progressBar.style.width = '40%'; progressBar.textContent = '40%'; return updateFirmwareStep(firmwareUrl, progressBar, statusText, autoBtn); }) .catch(err => { console.error('[AUTO-UPDATE] ERROR:', err); progressBar.classList.add('bg-danger'); statusText.textContent = '✗ Error: ' + err.message; autoBtn.disabled = false; autoBtn.innerHTML = '<i class="fa-solid fa-bolt"></i> Reintentar'; }); } else { updateFirmwareStep(firmwareUrl, progressBar, statusText, autoBtn) .catch(err => { console.error('[AUTO-UPDATE] ERROR:', err); progressBar.classList.add('bg-danger'); statusText.textContent = '✗ Error: ' + err.message; autoBtn.disabled = false; autoBtn.innerHTML = '<i class="fa-solid fa-bolt"></i> Reintentar'; }); }}function updateFirmwareStep(firmwareUrl, progressBar, statusText, autoBtn) { statusText.textContent = 'Descargando firmware...'; return fetch('/updateAuto?url=' + encodeURIComponent(firmwareUrl)) .then(response => response.text()) .then(data => { if (data.includes('Starting')) { progressBar.style.width = '75%'; progressBar.textContent = '75%'; statusText.textContent = 'ESP32 instalando firmware... (~30 segundos)'; return new Promise((resolve) => { setTimeout(function () { progressBar.classList.remove('progress-bar-animated'); progressBar.classList.add('bg-success'); progressBar.style.width = '100%'; progressBar.textContent = '100%'; statusText.textContent = '✓ Actualización completada! El ESP32 se reiniciará...'; setTimeout(function () { var modal = bootstrap.Modal.getInstance(document.getElementById('updateModal')); modal.hide(); showToast('success', 'Firmware actualizado! Reconectando...', 5000); setTimeout(function () { location.reload(); }, 10000); }, 2000); resolve(); }, 30000); }); } else { throw new Error('Error al iniciar actualización'); } });}function updateWifiStatus() { fetch('/getWifiStatus') .then(r => r.json()) .then(data => { var statusBadge = document.getElementById('wifiStatusBadge'); var ssidSpan = document.getElementById('wifiSSID'); if (data.connected) { statusBadge.className = 'info-badge bg-success'; ssidSpan.textContent = data.ssid; } else { statusBadge.className = 'info-badge bg-danger'; ssidSpan.textContent = i18n.t('wifi_status.disconnected') || 'Disconnected'; } }) .catch(err => { console.error('[GET-WIFI] ERROR:', err); var statusBadge = document.getElementById('wifiStatusBadge'); var ssidSpan = document.getElementById('wifiSSID'); statusBadge.className = 'info-badge bg-danger'; ssidSpan.textContent = i18n.t('wifi_status.error') || 'Error'; });}function updateLdrValue() { var isAutoEnabled = document.getElementById('autobrightness').checked; if (!isAutoEnabled) return; fetch('/getLdrValue') .then(r => r.json()) .then(data => { document.getElementById('ldrPercentage').textContent = data.percentage; document.getElementById('currentBrightnessValue').textContent = data.brightness; }) .catch(err => { console.error('[LDR] ERROR: ', err); document.getElementById('ldrPercentage').textContent = '--'; document.getElementById('currentBrightnessValue').textContent = '--'; });}function updateFirmwareBadge(status, version) { var firmwareBadge = document.querySelector('.info-badge.firmware-badge'); if (!firmwareBadge) { firmwareBadge = document.getElementById('firmwareVersion'); if (firmwareBadge) { firmwareBadge = firmwareBadge.closest('.info-badge'); } } if (!firmwareBadge) { console.warn('[FIRMWARE-BADGE] No se encontró el badge de firmware'); return; } firmwareBadge.classList.remove('bg-info', 'bg-warning', 'bg-danger', 'bg-success'); switch(status) { case 'uptodate': firmwareBadge.classList.add('bg-info'); firmwareBadge.style.cursor = 'default'; firmwareBadge.removeAttribute('data-bs-toggle'); firmwareBadge.removeAttribute('data-bs-target'); break; case 'available': firmwareBadge.classList.add('bg-warning'); firmwareBadge.style.cursor = 'pointer'; firmwareBadge.setAttribute('data-bs-toggle', 'modal'); firmwareBadge.setAttribute('data-bs-target', '#updateModal'); firmwareBadge.title = `Update available: v${version}`; break; case 'staged': firmwareBadge.classList.add('bg-danger'); firmwareBadge.style.cursor = 'pointer'; firmwareBadge.setAttribute('data-bs-toggle', 'modal'); firmwareBadge.setAttribute('data-bs-target', '#updatePathModal'); firmwareBadge.title = `Staged update required → v${version}`; break; } console.log(`[FIRMWARE-BADGE] Estado: ${status}, Versión: ${version}`);}function compareVersions(v1, v2) { const parts1 = v1.split('.').map(Number); const parts2 = v2.split('.').map(Number); for (let i = 0; i < 3; i++) { if (parts1[i] > parts2[i]) return 1; if (parts1[i] < parts2[i]) return -1; } return 0;}function loadVersionInfo(testMode = false) { fetch('/getDeviceInfo') .then(r => r.json()) .then(data => { CURRENT_VERSION = data.version; FIRMWARE_CHANNEL = data.channel || 'stable'; document.getElementById('footerVersion').textContent = data.version; document.getElementById('updateCurrentVersion').textContent = data.version; document.getElementById('firmwareVersion').textContent = `v${data.version}`; document.getElementById('updateChannelDisplay').textContent = data.channel || 'stable'; if (data.hostname) { document.getElementById('hostnameText').textContent = data.hostname_dns; document.getElementById('mdnsHostnameLink').href = `http://${data.hostname_dns}`; } if (data.updateServer) { window.UPDATE_SERVER_URL = data.updateServer; } DEVICE = data; if (testMode) { console.warn('====== SANDBOX MODE | DEBUGGING ======'); console.warn('FIRMWARE V:', DEVICE.version); console.warn('FIRMWARE C:', DEVICE.channel); console.warn('MAC:', DEVICE.mac); console.warn('DEVICE ID:', DEVICE.device); console.warn('HOSTNAME:', DEVICE.hostname); console.warn('UPDATE SERVER:', data.updateServer); console.warn('===================================='); } }) .catch(err => { console.error('[VERSION] ERROR:', err); });}function calculateUpdatePath(allVersions, currentVersion, targetVersion) { let path = []; let visited = new Set(); let sortedVersions = allVersions.slice().sort((a, b) => { return compareVersions(a.version, b.version); }); let current = currentVersion; let maxIterations = 20; let iterations = 0; while (compareVersions(current, targetVersion) < 0 && iterations < maxIterations) { iterations++; let nextVersion = null; for (let v of sortedVersions) { if (visited.has(v.version)) continue; if (compareVersions(v.version, current) <= 0) continue; if (compareVersions(v.version, targetVersion) > 0) continue; let minVer = v.minVersion || "0.0.0"; if (compareVersions(current, minVer) >= 0) { if (!nextVersion || compareVersions(v.version, nextVersion.version) < 0) { nextVersion = v; } } } if (!nextVersion) { console.error('[UPDATE-PATH] No se encontró camino hacia', targetVersion, 'desde', current); return null; } path.push(nextVersion); visited.add(nextVersion.version); current = nextVersion.version; } return path;}function showUpdatePath(path, targetVersion) { document.getElementById('pathTargetVersion').textContent = targetVersion; document.getElementById('pathCurrentVersion').textContent = CURRENT_VERSION; let stepsContainer = document.getElementById('updatePathSteps'); stepsContainer.innerHTML = ''; path.forEach((step, index) => { let stepDiv = document.createElement('div'); stepDiv.className = 'list-group-item'; let stepNumber = index + 1; let isFinal = (index === path.length - 1); let badgeClass = isFinal ? 'bg-success' : 'bg-primary'; stepDiv.innerHTML = ` <div class="d-flex w-100 justify-content-between align-items-center"><h6 class="mb-1"><span class="badge ${badgeClass}">Paso ${stepNumber}</span> Actualizar a v${step.version} </h6><small>${step.critical ? '<span class="badge bg-danger">CRÍTICO</span>' : ''}</small></div><p class="mb-1 small">${step.releaseNotes || 'Sin notas de versión'}</p> ${step.minVersion && step.minVersion !== "0.0.0" ? `<small class="text-muted"><i class="fa-solid fa-info-circle"></i> Requiere versión mínima: ${step.minVersion}</small>` : '' } `; stepsContainer.appendChild(stepDiv); }); window.currentUpdatePath = path; window.currentPathIndex = 0; updateFirmwareBadge('staged', targetVersion);}function startPathUpdate() { if (!window.currentUpdatePath || window.currentUpdatePath.length === 0) { alert('No hay camino de actualización definido'); return; } let firstStep = window.currentUpdatePath[0]; if (confirm(`¿Iniciar actualización a v${firstStep.version}?\n\nDespués de esta actualización, el dispositivo se reiniciará y deberás continuar con los pasos siguientes.`)) { localStorage.setItem('updatePath', JSON.stringify(window.currentUpdatePath)); localStorage.setItem('pathIndex', '0'); window.latestFirmwareUrl = firstStep.downloadUrl; window.latestWebAssets = firstStep.webAssets || []; let pathModal = bootstrap.Modal.getInstance(document.getElementById('updatePathModal')); if (pathModal) pathModal.hide(); document.getElementById('updateNewVersion').textContent = firstStep.version; document.getElementById('updateCurrentVersion').textContent = CURRENT_VERSION; document.getElementById('updateReleaseNotes').innerHTML = (firstStep.releaseNotes || 'Sin notas').replace(/\n/g, '<br>'); autoUpdateFirmware(); }}function checkForUpdates() { var updateServerInput = document.getElementById('updateServerUrl'); var updateServerUrl = (updateServerInput && updateServerInput.value) ? updateServerInput.value : window.UPDATE_SERVER_URL; if (!updateServerUrl) { console.warn('[UPDATES] No update server URL configured. Skipping update check.'); return; } var updateChannelInput = document.getElementById('updateChannel'); var currentChannel = (updateChannelInput && updateChannelInput.value) ? updateChannelInput.value : FIRMWARE_CHANNEL; console.log('[UPDATES] Checking updates from:', updateServerUrl); console.log('[UPDATES] Channel:', currentChannel); fetch(updateServerUrl + '?tstamp=' + Date.now()) .then(r => r.json()) .then(data => { let latestVersion, releaseNotes, downloadUrl, webAssets = []; if (data.tag_name) { latestVersion = data.tag_name.replace(/^v/, ''); releaseNotes = data.body || 'Sin notas de versión'; const binAsset = data.assets.find(a => a.name.endsWith('.bin')); downloadUrl = binAsset ? binAsset.browser_download_url : data.html_url; data.assets.forEach(function (asset) { if (asset.name === 'index.html') { webAssets.push({ name: asset.name, url: asset.browser_download_url, path: '/index.html' }); } else if (asset.name === 'style.css') { webAssets.push({ name: asset.name, url: asset.browser_download_url, path: '/style.css' }); } }); console.log('[UPDATES] GitHub Releases - Assets found:', webAssets.length); } else if (data.channels) { let channelData = data.channels[currentChannel]; if (!channelData) { console.error('[UPDATES] Canal "' + currentChannel + '" no encontrado en updates.json'); console.error('[UPDATES] Canales disponibles:', Object.keys(data.channels).join(', ')); return; } if (Array.isArray(channelData)) { if (channelData.length === 0) { console.log('[UPDATES] Canal "' + currentChannel + '" sin versiones disponibles'); return; } let newerVersions = channelData.filter(function (update) { return compareVersions(update.version, CURRENT_VERSION) > 0; }); if (newerVersions.length === 0) { console.log('[UPDATES] Sistema actualizado. Versión actual:', CURRENT_VERSION); return; } let latestVersion = newerVersions[0]; let minVersionRequired = latestVersion.minVersion || "0.0.0"; let isDirectlyCompatible = compareVersions(CURRENT_VERSION, minVersionRequired) >= 0; if (!isDirectlyCompatible) { console.log('[UPDATES] Versión más nueva (v' + latestVersion.version + ') requiere pasos intermedios'); let path = calculateUpdatePath( channelData, CURRENT_VERSION, latestVersion.version ); if (path && path.length > 0) { console.log('[UPDATES] Camino encontrado:', path.map(v => v.version).join(' → ')); showUpdatePath(path, latestVersion.version); return; } else { console.error('[UPDATES] No se pudo calcular camino de actualización'); return; } } channelData = latestVersion; console.log('[UPDATES] Versión más nueva disponible:', channelData.version); console.log('[UPDATES] Directamente compatible (minVersion:', minVersionRequired, ')'); } latestVersion = channelData.version; releaseNotes = channelData.releaseNotes || 'Sin notas de versión'; downloadUrl = channelData.downloadUrl; webAssets = channelData.webAssets || []; if (channelData.releaseDate) { console.log('[UPDATES] Fecha de release:', channelData.releaseDate); } if (channelData.critical) { console.warn('[UPDATES] ⚠️ ACTUALIZACIÓN CRÍTICA - Se recomienda instalar inmediatamente'); releaseNotes = '⚠️ **ACTUALIZACIÓN CRÍTICA**\n\n' + releaseNotes; } console.log('[UPDATES] Canal configurado:', currentChannel); console.log('[UPDATES] Versión disponible:', latestVersion); console.log('[UPDATES] Web assets:', webAssets.length); } else { console.error('[UPDATES] Formato de respuesta desconocido'); return; } window.latestFirmwareUrl = downloadUrl; window.latestWebAssets = webAssets; if (compareVersions(latestVersion, CURRENT_VERSION) > 0) { updateFirmwareBadge('available', latestVersion); document.getElementById('updateNewVersion').textContent = latestVersion; document.getElementById('updateCurrentVersion').textContent = CURRENT_VERSION; document.getElementById('updateReleaseNotes').innerHTML = releaseNotes.replace(/\n/g, '<br>'); document.getElementById('updateDownloadBtn').href = downloadUrl; } else { updateFirmwareBadge('uptodate', CURRENT_VERSION); console.log('[UPDATES] Sistema actualizado. Versión actual:', CURRENT_VERSION); } }) .catch(err => { console.error('[UPDATES] ERROR:', err); });}function getTestIP() { const urlParams = new URLSearchParams(window.location.search); return urlParams.get('ip');}function getBaseURL() { const testIP = getTestIP(); if (testIP) { return 'http://' + testIP; } return '';}const originalFetch = window.fetch;window.fetch = function (url, options) { if (typeof url === 'string' && url.startsWith('/')) { url = getBaseURL() + url; } return originalFetch(url, options);};class I18n { constructor() { this.currentLang = null; this.translations = {}; this.defaultLang = 'es'; this.supportedLangs = ['es', 'en']; this.remoteBaseUrl = window.I18N_REMOTE_URL || null; } detectBrowserLanguage() { let browserLang = navigator.language || navigator.userLanguage; browserLang = browserLang.split('-')[0].toLowerCase(); if (this.supportedLangs.includes(browserLang)) { return browserLang; } return this.defaultLang; } async loadTranslations(lang) { try { const url = this.remoteBaseUrl ? `${this.remoteBaseUrl}/${lang}.json` : `lang/${lang}.json`; console.log(`[i18n] Cargando desde: ${this.remoteBaseUrl ? 'REMOTO' : 'local'}`); const response = await fetch(url); if (!response.ok) { throw new Error(`Error loading ${lang}.json: ${response.status}`); } this.translations = await response.json(); this.currentLang = lang; console.log(`[i18n] ✓ Traducciones cargadas: ${lang} (${this.remoteBaseUrl ? 'remoto' : 'local'})`); return true; } catch (error) { console.error(`[i18n] Error cargando traducciones:`, error); if (this.remoteBaseUrl) { console.warn(`[i18n] Fallback a archivos locales...`); const wasRemote = this.remoteBaseUrl; this.remoteBaseUrl = null; const result = await this.loadTranslations(lang); this.remoteBaseUrl = wasRemote; return result; } if (lang !== this.defaultLang) { console.log(`[i18n] Intentando cargar idioma por defecto: ${this.defaultLang}`); return this.loadTranslations(this.defaultLang); } return false; } } t(key) { const keys = key.split('.'); let value = this.translations; for (const k of keys) { if (value && typeof value === 'object' && k in value) { value = value[k]; } else { console.warn(`[i18n] Traducción no encontrada: ${key}`); return key; } } return value; } applyTranslations() { document.documentElement.lang = this.currentLang; const elements = document.querySelectorAll('[data-i18n]'); elements.forEach(element => { const key = element.getAttribute('data-i18n'); const translation = this.t(key); const attr = element.getAttribute('data-i18n-attr'); if (attr) { element.setAttribute(attr, translation); } else { if (element.children.length === 0) { element.textContent = translation; } else { const textNodes = Array.from(element.childNodes).filter( node => node.nodeType === Node.TEXT_NODE ); if (textNodes.length > 0) { textNodes[textNodes.length - 1].textContent = translation; } } } }); console.log(`[i18n] Traducciones aplicadas al DOM (${elements.length} elementos)`); } async changeLanguage(lang) { if (!this.supportedLangs.includes(lang)) { console.error(`[i18n] Idioma no soportado: ${lang}`); return false; } if (lang === this.currentLang) { console.log(`[i18n] Idioma ya está activo: ${lang}`); return true; } const success = await this.loadTranslations(lang); if (success) { this.applyTranslations(); localStorage.setItem('preferred_lang', lang); window.dispatchEvent(new CustomEvent('languageChanged', { detail: { lang: lang } })); } return success; } async init() { const savedLang = localStorage.getItem('preferred_lang'); let langToLoad = savedLang && this.supportedLangs.includes(savedLang) ? savedLang : this.detectBrowserLanguage(); console.log(`[i18n] Inicializando con idioma: ${langToLoad}`); const success = await this.loadTranslations(langToLoad); if (success) { if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => { this.applyTranslations(); window.dispatchEvent(new CustomEvent('i18nReady', { detail: { lang: this.currentLang } })); }); } else { this.applyTranslations(); window.dispatchEvent(new CustomEvent('i18nReady', { detail: { lang: this.currentLang } })); } } return success; } getCurrentLanguage() { return this.currentLang; } getSupportedLanguages() { return this.supportedLangs; } tWithParams(key, params) { let translation = this.t(key); for (const [param, value] of Object.entries(params)) { translation = translation.replace(`{${param}}`, value); } return translation; }}const i18n = new I18n();window.i18n = i18n;i18n.init();if (typeof module !== 'undefined' && module.exports) { module.exports = i18n;}